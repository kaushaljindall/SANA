// @ts-nocheck
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Fixed: TypeScript strict import, Lip Sync Logic & Console Warnings
*/

import * as THREE from 'three'
import React, { useEffect, useMemo, useRef, useState } from 'react'
import { useGraph, useFrame, useThree } from '@react-three/fiber'
import { useGLTF, useAnimations } from '@react-three/drei'
import { SkeletonUtils } from 'three-stdlib'
import { Lipsync } from 'wawa-lipsync'

const facialExpressions = {
    default: {},
    smile: {
        browInnerUp: 0.17,
        eyeSquintLeft: 0.4,
        eyeSquintRight: 0.44,
        noseSneerLeft: 0.17,
        noseSneerRight: 0.14,
        mouthPressLeft: 0.61,
        mouthPressRight: 0.41,
    },
    sad: {
        mouthFrownLeft: 1,
        mouthFrownRight: 1,
        mouthShrugLower: 0.78,
        browInnerUp: 0.45,
        eyeSquintLeft: 0.72,
        eyeSquintRight: 0.75,
        eyeLookDownLeft: 0.5,
        eyeLookDownRight: 0.5,
        jawForward: 1,
    },
    surprised: {
        eyeWideLeft: 0.5,
        eyeWideRight: 0.5,
        jawOpen: 0.35,
        mouthFunnel: 0.35,
        browInnerUp: 1,
    },
    angry: {
        browDownLeft: 1,
        browDownRight: 1,
        eyeSquintLeft: 1,
        eyeSquintRight: 1,
        jawForward: 1,
        jawLeft: 1,
        mouthShrugLower: 1,
        noseSneerLeft: 1,
        noseSneerRight: 0.42,
        eyeLookDownLeft: 0.16,
        eyeLookDownRight: 0.16,
        cheekSquintLeft: 1,
        cheekSquintRight: 1,
        mouthClose: 0.23,
        mouthFunnel: 0.63,
        mouthDimpleRight: 1,
    },
    crazy: {
        browInnerUp: 0.9,
        jawForward: 1,
        noseSneerLeft: 0.57,
        noseSneerRight: 0.51,
        eyeLookDownLeft: 0.39,
        eyeLookUpRight: 0.4,
        eyeLookInLeft: 0.96,
        eyeLookInRight: 0.96,
        jawOpen: 0.96,
        mouthDimpleLeft: 0.96,
        mouthDimpleRight: 0.96,
        mouthStretchLeft: 0.27,
        mouthStretchRight: 0.28,
        mouthSmileLeft: 0.55,
        mouthSmileRight: 0.38,
        tongueOut: 0.96,
    },
}

export const Ziva = React.forwardRef(({ audioUrl, expression, animation, animationTrigger, ...props }, ref) => {
    const VISEME_INTENSITY = 1.0 // Reduced slightly for better blending
    const LERP_SPEED = 0.25
    const VISEME_LERP_SPEED = 0.5 // Faster lerp for mouth movement

    const group = useRef(null)
    const { scene } = useGLTF('/models/Ziva.glb')
    const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene])
    const { nodes, materials } = useGraph(clone)
    const { gl } = useThree()

    // 1. Texture Quality Fix
    useEffect(() => {
        const anisotropy = gl.capabilities.getMaxAnisotropy();
        scene.traverse((object) => {
            if (object.isMesh) {
                if (object.material.map) object.material.map.anisotropy = anisotropy;
                if (object.material.emissiveMap) object.material.emissiveMap.anisotropy = anisotropy;
                if (object.material.roughnessMap) object.material.roughnessMap.anisotropy = anisotropy;
                if (object.material.metalnessMap) object.material.metalnessMap.anisotropy = anisotropy;
                if (object.material.normalMap) object.material.normalMap.anisotropy = anisotropy;
                object.castShadow = true;
                object.receiveShadow = true;
            }
        });
    }, [gl, scene]);

    // Expose the head node via ref
    React.useImperativeHandle(ref, () => ({
        head: nodes.Wolf3D_Head,
        group: group.current
    }));

    // 2. Animation Logic (With Warning Fixes)
    const { animations: clips } = useGLTF('/models/Animations.glb')

    useMemo(() => {
        if (clips) {
            clips.forEach((clip) => {
                if (clip.tracks) {
                    // Filter out tracks that cause "No target node found" warnings
                    clip.tracks = clip.tracks.filter((track) => {
                        const trackName = track.name.toLowerCase();
                        return !trackName.includes('end') &&
                            !trackName.includes('nub') &&
                            !trackName.includes('armature');
                    });

                    // Rename mixamo bones to match Ready Player Me skeleton
                    clip.tracks.forEach((track) => {
                        track.name = track.name.replace('mixamorig', '')
                    })
                }
            })
        }
    }, [clips])

    const { actions, names } = useAnimations(clips || [], group)
    const [currentAnimation, setCurrentAnimation] = useState(names[0])
    const [currentExpression, setCurrentExpression] = useState('default')
    const animationTimeoutRef = useRef(null)
    const expressionTimeoutRef = useRef(null)

    // Handle expression changes with auto-reset to default after 2 seconds
    useEffect(() => {
        if (expression && expression !== 'default') {
            setCurrentExpression(expression)

            // Clear any existing timeout
            if (expressionTimeoutRef.current) {
                clearTimeout(expressionTimeoutRef.current)
            }

            // Reset to default after 2 seconds
            expressionTimeoutRef.current = setTimeout(() => {
                setCurrentExpression('default')
            }, 2000)
        } else if (expression === 'default') {
            setCurrentExpression('default')
        }

        return () => {
            if (expressionTimeoutRef.current) {
                clearTimeout(expressionTimeoutRef.current)
            }
        }
    }, [expression])

    useEffect(() => {
        // If parent provides an animation, use it. Otherwise, default/idle.
        if (animation && names.includes(animation)) {
            setCurrentAnimation(animation)

            // Clear any existing timeout
            if (animationTimeoutRef.current) {
                clearTimeout(animationTimeoutRef.current)
            }

            // Set timeout to return to Idle after 30 seconds (unless already Idle)
            if (animation !== 'Idle') {
                animationTimeoutRef.current = setTimeout(() => {
                    setCurrentAnimation('Idle')
                }, 10000)
            }
        }

        return () => {
            if (animationTimeoutRef.current) {
                clearTimeout(animationTimeoutRef.current)
            }
        }
    }, [animation, names, animationTrigger]) // Added animationTrigger to dependencies

    useEffect(() => {
        if (!currentAnimation || !actions[currentAnimation]) return

        const action = actions[currentAnimation]
        action
            .reset()
            .fadeIn(0.5)
            .play()

        // Listen for animation completion and return to Idle
        // (This handles animations that complete before 30s timeout)
        const onFinished = () => {
            if (currentAnimation !== 'Idle') {
                setCurrentAnimation('Idle')
            }
        }

        // Set loop mode - Idle and Talking should loop, others play once
        if (currentAnimation === 'Idle' || currentAnimation === 'Talking') {
            action.setLoop(2201, Infinity) // LoopRepeat
        } else {
            action.setLoop(2200, 1) // LoopOnce
            action.clampWhenFinished = true

            const mixer = action.getMixer()
            mixer?.addEventListener('finished', onFinished)
        }

        return () => {
            action?.fadeOut(0.5)

            const mixer = action?.getMixer()
            mixer?.removeEventListener('finished', onFinished)
        }
    }, [currentAnimation, actions])

    // 3. Audio & Lipsync Setup
    const lipsyncRef = useRef(new Lipsync())
    const audioRef = useRef(null)
    const lipsyncConnectedRef = useRef(false)

    useEffect(() => {
        if (!audioUrl) {
            // Clean up if no audio URL
            if (audioRef.current) {
                audioRef.current.pause()
                audioRef.current = null;
            }
            lipsyncConnectedRef.current = false;
            return;
        }

        // Reset lipsync state for a new audio source
        lipsyncRef.current = new Lipsync()
        lipsyncConnectedRef.current = false

        // ALWAYS create a new Audio element to avoid MediaElementSourceNode conflicts
        // Clean up old audio if exists
        if (audioRef.current) {
            audioRef.current.pause();
            audioRef.current.src = '';
        }

        // Create fresh Audio element
        audioRef.current = new Audio();
        audioRef.current.crossOrigin = 'anonymous';
        audioRef.current.src = audioUrl;

        // Wait for audio to be ready, then connect lipsync and play
        const handleCanPlay = async () => {
            try {
                if (audioRef.current && !lipsyncConnectedRef.current) {
                    lipsyncRef.current.connectAudio(audioRef.current)
                    lipsyncConnectedRef.current = true;
                    await audioRef.current.play();
                }
            } catch (e) {
                console.error('Error playing audio:', e);
            }
        };

        audioRef.current.addEventListener('canplay', handleCanPlay, { once: true });
        audioRef.current.load(); // Explicitly load the audio

        return () => {
            if (audioRef.current) {
                audioRef.current.removeEventListener('canplay', handleCanPlay);
                audioRef.current.pause();
            }
            lipsyncConnectedRef.current = false
        };
    }, [audioUrl]);

    // 4. Blinking
    const [blink, setBlink] = useState(false)
    useEffect(() => {
        let blinkTimeout
        const nextBlink = () => {
            blinkTimeout = setTimeout(() => {
                setBlink(true)
                setTimeout(() => {
                    setBlink(false)
                    nextBlink()
                }, 200)
            }, THREE.MathUtils.randInt(1000, 5000))
        }
        nextBlink()
        return () => clearTimeout(blinkTimeout)
    }, [])

    // Calculate the actual expression to use: currentExpression > Default
    const activeExpression = currentExpression || 'default'

    // 6. Frame Loop
    useFrame(() => {
        const lipsync = lipsyncRef.current
        const head = nodes.Wolf3D_Head
        const teeth = nodes.Wolf3D_Teeth

        if (!head || !lipsync) return

        // A. Analyze Audio
        if (audioRef.current && lipsyncConnectedRef.current) {
            lipsync.processAudio()
        }

        // B. Check if audio is playing
        const isAudioPlaying = audioRef.current && !audioRef.current.paused && !audioRef.current.ended

        // The library returns values like "viseme_aa", "viseme_sil" directly
        const currentViseme = lipsync.viseme

        // C. Expressions
        const expressionValues = isAudioPlaying ? {} : (facialExpressions[activeExpression] || {})

        // D. Morph Targets
        Object.keys(head.morphTargetDictionary || {}).forEach((key) => {
            const targetIndex = head.morphTargetDictionary[key]
            const teethIndex = teeth.morphTargetDictionary[key]

            let targetValue = 0

            // Base Expression
            if (expressionValues[key]) {
                targetValue = expressionValues[key]
            }

            // Blinking
            if (key === 'eyeBlinkLeft' || key === 'eyeBlinkRight') {
                targetValue = blink ? 1 : 0
            }

            // Lip Sync Logic
            if (key.startsWith('viseme_') && isAudioPlaying) {
                // FIXED: currentViseme already includes the "viseme_" prefix,
                // so we compare directly instead of adding it again.
                if (key === currentViseme) {
                    targetValue = VISEME_INTENSITY
                }
            }

            // Determine lerp speed based on what we are animating
            const lerpSpeed = (key.startsWith('viseme_') && isAudioPlaying)
                ? VISEME_LERP_SPEED
                : LERP_SPEED

            // Apply with lerp
            head.morphTargetInfluences[targetIndex] = THREE.MathUtils.lerp(
                head.morphTargetInfluences[targetIndex],
                targetValue,
                lerpSpeed
            )

            if (teethIndex !== undefined) {
                teeth.morphTargetInfluences[teethIndex] = THREE.MathUtils.lerp(
                    teeth.morphTargetInfluences[teethIndex],
                    targetValue,
                    lerpSpeed
                )
            }
        })
    })

    return (
        <group ref={group} {...props} dispose={null}>
            <primitive object={nodes.Hips} />
            <skinnedMesh geometry={nodes.Wolf3D_Hair.geometry} material={materials.Wolf3D_Hair} skeleton={nodes.Wolf3D_Hair.skeleton} />
            <skinnedMesh geometry={nodes.Wolf3D_Outfit_Top.geometry} material={materials.Wolf3D_Outfit_Top} skeleton={nodes.Wolf3D_Outfit_Top.skeleton} />
            <skinnedMesh geometry={nodes.Wolf3D_Outfit_Bottom.geometry} material={materials.Wolf3D_Outfit_Bottom} skeleton={nodes.Wolf3D_Outfit_Bottom.skeleton} />
            <skinnedMesh geometry={nodes.Wolf3D_Outfit_Footwear.geometry} material={materials.Wolf3D_Outfit_Footwear} skeleton={nodes.Wolf3D_Outfit_Footwear.skeleton} />
            <skinnedMesh geometry={nodes.Wolf3D_Body.geometry} material={materials.Wolf3D_Body} skeleton={nodes.Wolf3D_Body.skeleton} />
            <skinnedMesh name="EyeLeft" geometry={nodes.EyeLeft.geometry} material={materials.Wolf3D_Eye} skeleton={nodes.EyeLeft.skeleton} morphTargetDictionary={nodes.EyeLeft.morphTargetDictionary} morphTargetInfluences={nodes.EyeLeft.morphTargetInfluences} />
            <skinnedMesh name="EyeRight" geometry={nodes.EyeRight.geometry} material={materials.Wolf3D_Eye} skeleton={nodes.EyeRight.skeleton} morphTargetDictionary={nodes.EyeRight.morphTargetDictionary} morphTargetInfluences={nodes.EyeRight.morphTargetInfluences} />
            <skinnedMesh name="Wolf3D_Head" geometry={nodes.Wolf3D_Head.geometry} material={materials.Wolf3D_Skin} skeleton={nodes.Wolf3D_Head.skeleton} morphTargetDictionary={nodes.Wolf3D_Head.morphTargetDictionary} morphTargetInfluences={nodes.Wolf3D_Head.morphTargetInfluences} />
            <skinnedMesh name="Wolf3D_Teeth" geometry={nodes.Wolf3D_Teeth.geometry} material={materials.Wolf3D_Teeth} skeleton={nodes.Wolf3D_Teeth.skeleton} morphTargetDictionary={nodes.Wolf3D_Teeth.morphTargetDictionary} morphTargetInfluences={nodes.Wolf3D_Teeth.morphTargetInfluences} />
        </group>
    )
})

useGLTF.preload('/models/Ziva.glb')
useGLTF.preload('/models/Animations.glb')
